Возвращение мести
Резюме: вам придется начать с мини-оболочки и сделать ее более прочной, чтобы более-мение приблизить её к настоящей функциональной оболочке. Вы добавите несколько функций, таких как многокомандное управление, перенаправления, а также линейное издание, которое позволит вам использовать стрелки, например.

Глава I

Предисловие

I.1 Как сделать идеальный чизкейк

Служит от 8 до 10

I.2 Что вам нужно

I.2.1 Ингредиенты

Для чизкейка:
• 2 фунта сливочного сыра
• 1 чашка сахара
• 1 столовая ложка кукурузного крахмала или 2 столовые ложки универсальной муки (по желанию)
• 1/8 чайной ложки соли
• 1/2 стакана сметаны
• 2 чайные ложки лимонного сока (по желанию)
• 1 чайная ложка ванильного экстракта
• 3 больших яйца
• 1 большой яичный желток

Для коры:

• 12 целых прямоугольников крекера Грэма (6 унций)
• 5 столовых ложек сливочного масла, а также дополнительно смазать сковороду

I.2.2 Оборудование

• 9-дюймовая или 10-дюймовая кастрюля с пружинной формой
• Алюминиевая фольга
• Кухонный комбайн
• Стенд миксер или ручной миксер
• мерные чашки и ложки
• шпатель
• Жаровня или другое блюдо, достаточно большое, чтобы вмещать форму

I.2.3 Инструкции

• Разогрейте духовку и нагрейте сливочный сыр: разогрейте духовку до 350 ° F стойка в нижнем среднем положении. Возьмите кусочки сливочного сыра из их коробки и дайте им нагреться на прилавке, пока вы готовите корочку, около 30 минут.
• Протрите сковороду с маслом: пальцами потрите маленький кусочек масла по всему дно и бока сковороды.
• Заверните сковороду в фольгу: отрежьте два больших куска фольги и положите их на рабочую поверхность крестом. Установите противень в середине и сложите края фольги вокруг сторон кастрюли. Фольга дает вам дополнительную защиту от воды попасть в кастрюлю во время шага с водяной баней.
• Приготовить корочку: раздавить крекеры Грэм в кухонном комбайне (или в мешке, используя скалкой), пока они не образуют мелкие крошки - у вас должно быть от 1 1/2 до 2 чашек. Плавиться 5 столовых ложек масла в микроволновке или на плите и смешайте это в крошки крекера Грэма. Смесь должна выглядеть как влажный песок и скрепляться в комок, когда вы нажимаете его в кулак. Если нет, добавьте дополнительные столовые ложки воды (один раз), пока смесь не скрепится. Перенести его в форму для выпечки и используйте дно стакана, чтобы равномерно вдавить его в дно. (Пошагово инструкции к этому шагу см. в разделе «Как сделать корку из крекера Грэма».)
• Испеките корку: поместите корку в духовку (будьте осторожны, чтобы не порвать фольгу). Печь в течение 8-10 минут, пока корочка не станет ароматной и не начнет коричневеть края. Дайте корке остыть на охлаждающей подставке, пока вы готовите начинку.
• Смешайте сливочный сыр, сахар, кукурузный крахмал и соль: смешайте подогретые сливки сыр, сахар, кукурузный крахмал и соль в миске миксера с лопастью насадка (или используйте ручной миксер). Смешайте на средней-низкой скорости, пока смесь сливочный, как густая глазурь, без остатков сливочного сыра. Скрести колотушка и боковые части чаши с помощью шпателя.
• Смешайте сметану, лимонный сок и ваниль: добавьте сметану, лимонный сок, и ваниль к миске и взбейте на средней-низкой скорости, пока не смешано и сливочно. Соскребите колотушку и бока миски с помощью шпателя.
• Смешайте яйца и желток по одному: с миксером на средней-низкой скорости, взбейте в яйцах и желтке по одному. Подождите, пока предыдущее яйцо едва смешать в тесто, прежде чем добавить следующий. Сначала смесь будет выглядеть комковатые и разбитые, но они соберутся вместе с яйцами.
• Перемешайте несколько раз рукой: очистите венчик и бока миски с помощью шпатель. Размешайте все жидкое тесто несколько раз вручную, обязательно поцарапав дно чаши, чтобы убедиться, что все включено. Готовое тесто должен быть густым, кремовым и шелковистым. Не волнуйтесь, если увидите несколько пятен несмешанного сливочный сыр тут и там; они будут плавиться в тесте во время выпекания и не будут влияет на готовый чизкейк.
• Вылейте жидкое тесто на охлажденную корку: убедитесь, что корка и боковые стороны сковороды - это круто - если они достаточно прохладны, чтобы их было удобно трогать, вы можете продолжать. Вылейте жидкое тесто по охлажденной корке и распределите его в ровный слой против стороны кастрюли.
• Переместите кастрюлю на водяную баню: перенесите кастрюлю на жаровню или другое форма для выпечки достаточно большая, чтобы вместить ее. Доведите до кипения несколько чашек воды и налейте воду в жаровню, стараясь не выплеснуть воду на чизкейк. Заполните сковороду примерно на дюйм или чуть ниже самого нижнего края фольги.
• Запекать чизкейк: выпекать чизкейк при температуре 350 ° F в течение 50–60 минут. Торты запеченный в 10-дюймовой сковороде обычно готовится за 50-55 минут; торты в 9-дюймовой кастрюле будет готовить через 55-60 минут. Чизкейк готовят, когда наружу два-три дюймы выглядят слегка надутыми и затянутыми, но внутренний круг все еще покачивается (как желе), когда Вы осторожно встряхиваете кастрюлю. Некоторые пятна поджаренного золотистого цвета в порядке, но если вы увидеть любые трещины, начинающие формироваться, сразу перейти к следующему шагу.
• Охладите чизкейк в духовке: выключите духовку и откройте дверцу. Позволять Чизкейк медленно остудить в течение часа.
• Проведите ножом по краю пирога и полностью охладите пирог: после час, вынуть чизкейк из духовки и с водяной бани, развернуть фольгу и перенесите в охлаждающую стойку. Запустите нож с тонким лезвием по краю торт, чтобы убедиться, что он не прилипает к боковым сторонам (что может привести к появлению трещин охлаждает). Дайте чизкейку полностью остыть на вешалке.
• Охладите чизкейк в холодильнике в течение четырех часов: охладите чизкейк, Как минимум четыре часа или три дня в холодильнике. Этот шаг решающее значение для того, чтобы дать набору чизкейка и достичь идеальной текстуры чизкейка - не торопись.
• Выложить сверху чизкейк и подавать: вынуть чизкейк из холодильника примерно на 30 минут, прежде чем вы планируете служить. Разложить торт и положить сверху чизкейк перед подачей на стол. Вы можете подать торт прямо из нижней части формы пружины сковороде, или используйте большую смещенную лопаточку, чтобы аккуратно отделить корку от сковороды и перенести его на блюдо. Остатки будут храниться в открытом и охлажденном виде для несколько дней.

I.2.4 Идеи для того, чтобы возглавить свой чизкейк

• Нанесите сверху тонкий слой сметаны или взбитых сливок.
• Вылейте мягкий шоколадный ганаш поверх чизкейка
• Добавить нарезанные свежие фрукты, либо самостоятельно, либо с фруктовым сиропом
• Подогрейте немного арахисового масла с небольшим количеством сливок, чтобы получился соус, и полейте его чизкейк

Глава II

Вступление

Благодаря проекту Minishell, вы обнаружили часть того, что находится за сценой оболочки, например та, которую вы используете каждый день. И, более конкретно, синхронизация процесса созданного с помощью таких функций, как fork и wait.

Проект 21sh заставит вас пойти дальше, добавив, среди прочего,
процесс связи с использованием труб.

Вы обнаружите или откроете заново, если вы работали над проектом ft_select, termcaps. Это библиотека позволит вам добавить в вашу оболочку функцию линейного издания. Тогда вы сможете отредактируйте опечатку, сделанную по вашей команде, без необходимости перепечатывать ее полностью, а также повторите предыдущую команду, используя историю. Конечно, вам придется кодировать эти функции. Хорошая новость заключается в том, что termcaps поможет вам сделать это, плохая новость - он не сделает это за вас!

Глава III

Цели

Программирование на Unix отлично, 3 школьных проекта позволяют вам открыть для себя большую часть API системы, и она может быть полезна только для вас.

Тем не менее, проекты оболочки, прежде всего, являются интерпретаторами команд и инициируют очень важную часть ИТ: компиляция. Интерпретатор - это программы, которые читают и выполняют другие программы, в отличие от компиляторов, которые переводят другие программы в другие языки. Интерпретаторы и компиляторы имеют больше общего, чем различий: будь то выполнение или перевод программы, сначала нужно понять саму программу, и может быть в состоянии обнаружить и отклонить неправильно сформированные программы.

Вы, наверное, уже это знаете, но набор команд мы можем отправить в форму оболочки язык. Этот язык имеет лексические, синтаксические и семантические правила, которые должны быть уважаемы вашим 21sh, пройдя через ряд очень точных шагов, хорошо документированных в интернете. Например, раздел «2.10 Shell Grammar» этого документа.

Ключ к успешному 21sh, а позже 42sh - ясный и хорошо управляемый и организованный код. Будьте уверены, что простое разделение на основе пробелов в командной строке не будет сделать трюк здесь. Чтобы не терять время, рассмотрите это решение как билет в один конец катастрофы
.
Вот пара ключевых слов, которые я предлагаю вам правильно понять: «лексический анализ», «лексер», «синтаксический анализ», «анализатор», «анализ семантики», «интерпретатор» и конечно,  «абстрактное синтаксическое дерево» (или «AST»).

Глава IV

Основные инструкции

• Этот проект будет оцениваться только людьми. Вам разрешено организовывать и назовите свои файлы так, как считаете нужным, но вы должны следовать следующим правилам.

• Исполняемый файл должен иметь имя 21sh.

• Ваш Makefile должен компилировать проект и должен содержать обычные правила. Это должно перекомпилируйте и перекомпоновайте программу только при необходимости.

• Если вы умны, вы будете использовать свою библиотеку для своего 21sh. Отправить также вашу папку libft, включая собственный Makefile в корне вашего репозитория. Ваш Makefile придется скомпилировать библиотеку, а затем скомпилировать ваш проект.

• Ваш проект должен быть написан в соответствии с нормой. Только норминетт есть авторитетный.

• Вы должны тщательно обрабатывать ошибки. Ваша программа никоим образом не может выйти из определенным образом (ошибка сегментации, ошибка шины, двойное освобождение и т. д.).

• Ваша программа не может иметь утечек памяти.

• Вам нужно будет отправить файл с именем author, содержащий ваше имя пользователя, а затем ’\n’ в корне вашего хранилища.
(пример)

• В рамках обязательной части вам разрешено использовать только следующие функции libc:
	◦ malloc, free
	◦ access
	◦ open, close, read, write
	◦ opendir, readdir, closedir
	◦ getcwd, chdir
	◦ stat, lstat, fstat
	◦ fork, execve
	◦ wait, waitpid, wait3, wait4
	◦ signal, kill
	◦ exit
	◦ pipe
	◦ dup, dup2
	◦ isatty, ttyname, ttyslot
	◦ ioctl
	◦ getenv
	◦ tcsetattr, tcgetattr
	◦ tgetent
	◦ tgetflag
	◦ tgetnum
	◦ tgetstr
	◦ tgoto
	◦ tputs

• Вы можете использовать другие функции или другие библиотеки для завершения бонуса расстаться до тех пор, пока их использование оправдано во время вашей защиты. Быть умным!

• Вы можете задать свои вопросы на форуме или в slack...

Глава V

Обязательная часть

Начнем с того, что все функции мини-оболочки неявно являются частью 21-й обязательной части. Кроме того, вам нужно будет
добавить следующие новые функции:

• Возможность линейного редактирования с использованием библиотеки termcaps. Проверьте следующее описание ниже.

• Комбинация клавиш ctrl + D et ctrl + C для линейного редактирования и exe-выполнения процесса.

• Разделитель командной строки «;»

• Трубы «|»

• 4 следующих перенаправления «<», «>», «<<» и «>>»

• Агрегирование файловых дескрипторов, например, чтобы закрыть стандартный вывод ошибок:
(пример)

Вот типичный пример команд, которые должен выполнить ваш 21sh правильно:
(пример)

Что касается линейного издания, вы должны как минимум управлять следующими функциями ключи, которых будут использоваться
в качестве примеров, вы можете использовать другие, если ваша оболочка остается логичным и интуитивным. Человек, оценивающий
вас, решит, что логично и интуитивно понятный, поэтому будьте осторожны, чтобы не увлекаться творчеством.

• Отредактируйте строку, в которой находится курсор.

• Переместите курсор влево и вправо, чтобы иметь возможность редактировать строку в определенном месте. Очевидно, что новые
символы должны быть вставлены между существующими, аналогично как в классической оболочке.

• Используйте стрелки вверх и вниз для навигации по истории команд, которые мы будем тогда сможете редактировать, если нам
так хочется (строка, а не история).

• Вырезать, копировать и / или вставлять всю или часть строки, используя последовательность клавиш, которую вы предпочитаете.

• Переместиться непосредственно по слову влево или вправо, используя ctrl + LEFT и ctrl + RIGHT или любая другая разумная
комбинация клавиш.

• Перейти непосредственно к началу или концу строки, нажав начало и конец.

• Напишите И отредактируйте команду в несколько строк. В таком случае, мы хотели бы, чтобы Ctrl + UP и Ctrl + DOWN позволяют
переходить от одной строки к другой в команде оставаясь в том же столбце или иным образом наиболее подходящим столбцом.

• Полностью управлять кавычками и двойными кавычками, даже на нескольких строках  (расширения не входит).

Глава VI

Бонусная часть

Мы будем смотреть на ваши бонусы, если и только если ваша обязательная часть ОТЛИЧНО. Это означает, что вы должны выполнить обязательную часть, от начала до конца, и ваша ошибка управление должно быть безупречным, даже в случаях неправильного или неправильного использования. Если это не так, тогда в этом случае ваши бонусы будут полностью игнорироваться.

Есть немало функций, которые появятся в 42sh. Вот, однако, список бонусы, которые вы можете реализовать сразу:

• Поиск по истории с помощью Ctrl + R

• Реализовать хеш-таблицу для двоичных файлов

• Простое или расширенное завершение с помощью вкладки.

• Режим привязки Emacs и / или Vim свободно активируется или деактивируется.

• Синтаксическая окраска оболочки свободно активируется или деактивируется.

• Любой дополнительный бонус, который вам будет полезен.

Глава VII

Представление и экспертная оценка

Отправьте свою работу в свой репозиторий GiT как обычно. Только работа над вашим хранилищем будет оцениваться.

Удачи всем и не забудьте свой авторский файл!



access(): <io.h>
	int access(const char *filename, int mode):

	Функция access() относится к UNIX-подобной файловой системе и не определяется стандартом ANSI С.
	Она используется для проверки существования файла. Может использоваться и для того, чтобы выяснить,
	защищен ли файл от записи и является ли он исполняемым. Имя проверяемого файла указывается с помощью
	filename. Значение mode определяет, что именно проверяет access():

		Значение	Проверяет
		0	Существование файла
		1	Исполняемость файла
		2	Доступность для записи
		3	Доступность для чтения
		4	Доступность для чтения/записи

	return():
		Функция access() возвращает 0, если проверяемый вид доступа разрешен; в противном случае она возвращает —1.
		В случае ошибки заранее определенная глобальная переменная errno устанавливается в одно из следующих
		значений:

			ENOENT	Файл не найден
			EACCES	Нет доступа



tputs(): <curses.h>, <term.h>
	int tputs(const char *str, int affcnt, int (*putc)(int))



tgetent(): <curses.h>, <term.h>
	int tgetent(char *bp, const char *name)

	Процедура tgetent() загружает запись для имени.

	return():
		Возвращает 1 - в случае успеха, 0 - если такой записи нет, и -1 - если в базе данных terminfo могут быть 
		найдены заметки. Эмуляция игнорирует указатель буфера bp.



tgetflag(): <curses.h>, <term.h>
	int tgetflag(char *id)

	Процедура tgetflag() получает логическую запись для id или ноль, если её нет в наличии.



tgetnum(): <curses.h>, <term.h>
	int tgetnum(char *id)

	Подпрограмма tgetnum() получает числовую запись для id или -1, если она не доступна.



tgetstr(): <curses.h>, <term.h>
	char *tgetstr(char *id, char **area)

	Подпрограмма tgetstr() возвращает строковую запись для идентификатора или ноль, если её нет в наличии.



tgoto(): <curses.h>, <term.h>
	char *tgoto(const char *cap, int col, int row)

	Подпрограмма tgoto() создает параметры для заданной способности. Вывод этой подпрограммы должен быть
	передан в tputs.



int pipe(int *fd): <unistd.h>
	https://www.intuit.ru/studies/courses/2249/52/lecture/1554?page=4
	Параметр fd является указателем на массив из двух целых переменных. При нормальном 
	завершении вызова в первый элемент массива – fd[0] – будет занесен файловый дескриптор, 
	соответствующий выходному потоку данных pip’а и позволяющий выполнять только операцию 
	чтения, а во второй элемент массива – fd[1] – будет занесен файловый дескриптор, с
	оответствующий входному потоку данных и позволяющий выполнять только операцию записи.

	В процессе работы системный вызов организует выделение области памяти под буфер и
	указатели и заносит информацию, соответствующую входному и выходному потокам данных,
	в два элемента таблицы открытых файлов, связывая тем самым с каждым pip’ом два файловых
	дескриптора. Для одного из них разрешена только операция чтения из pip’а, а для другого
	– только операция записи в pipe . Для выполнения этих операций мы можем использовать
	те же самые системные вызовы read() и write() , что и при работе с файлами.
	Естественно, по окончании использования входного или/и выходного потока данных, нужно
	закрыть соответствующий поток с помощью системного вызова close() для освобождения
	системных ресурсов. Необходимо отметить, что, когда все процессы, использующие pipe ,
	закрывают все ассоциированные с ним файловые дескрипторы, операционная система
	ликвидирует pipe . Таким образом, время существования pip’а в системе не может
	превышать время жизни процессов, работающих с ним.

	LINUX API:
	int pipe(int filedes[2])
	Успешный вызов pipe() возвращает массив filedes с двумя открытыми файловыми
	дескрипторами: один для чтения (filedes[0]), второй — для записи (filedes[1]).

	Вызов ioctl(fd, FIONREAD, &cnt) возвращает количество непрочитанных байтов в канале
	или очереди FIFO, на которые ссылается дескриптор fd. Он доступен и в ряде других
	реализаций, но не описан в стандарте SUSv3.

	return():
		Системный вызов возвращает значение 0 при нормальном завершении и значение -1 
		при возникновении ошибок.



int dup(int handle): <io.h>
	http://www.c-cpp.ru/content/dup-dup2
	Функция dup() возвращает новый дескриптор файла, который полностью описывает
	(т.е. дуб­лирует) состояние файла, связанного с handle.

	return():
		В случае успеха возвращается неотрицательная величина, а в противном случае —1.



int dup2(int old_handle, int new_handle): <io.h>
	http://www.c-cpp.ru/content/dup-dup2
	Функция dup2() дублирует old_handle как new_handle. Если имеется файл, который
	был связан с new_handle до вызова dup2(), то он будет закрыт.

	return():
		В случае успеха возвращается 0, а в случае ошибки —1. При ошибке errno
		устанавливается в одно из следующих значений:
			EMFILE		Открыто слишком много файлов
			EBADF		Недействительный дескриптор файла



int isatty(int handle): <io.h>
	http://www.c-cpp.ru/content/isatty
	Она возвращает ненулевое значение, если handle связан с символьным устройством,
	например, терминалом, консолью, принтером или последовательным портом; в противном
	случае она возвращает 0.



char *ttyname(int fd): <unistd>
	man
	Функция ttyname() возвращает указатель на завершенный нулем путь к терминальному
	устройству, который открыт в файловом дескрипторе fd, или NULL в случае ошибки
	(например, если fd не подключен к терминалу). Возвращаемое значение может указывать
	на статические данные, которые могут быть перезаписаны при следующем вызове.
	Функция ttyname_r() сохраняет это имя пути в буфере buf длины buflen.
		int ttyname_r(int fd, char *buf, size_t buflen)

	return():
		Функция ttyname() возвращает указатель на путь в случае успеха. При ошибке
		возвращается NULL, и errno устанавливается соответствующим образом.
		Функция ttyname_r() возвращает 0 в случае успеха и номер ошибки при ошибке.



int ttyslot(void): <unistd.h>
		https://www.opennet.ru/man.shtml?topic=ttyslot&category=3&russian=0
		Функция ttyslot() возвращает индекс управляющего терминала текущего процесса
		в файле /etc/ttys, и (обычно) это то же самое, что и индекс записи для текущего
		пользователя в файле /etc/utmp. В BSD все еще существует файл /etc/ttys, но в
		системах SYSV его уже нет, и поэтому на него ссылаться нельзя. Таким образом,
		на таких системах документация говорит, что ttyslot() вовзращает текущий индекс
		пользователя в базе данных учетных записей.

		return():
			При нормальном завершении работы эта функция возвращает номер слота. При
			ошибках (например, если ни один из описателей файлов 0, 1 или 2 не
			ассоциирован с терминалом, указанном в этой базе данных) возвращаетсяb0 на
			системах Unix V6 и V7 и на BSD-подобных, но -1 на системах, подобных SYSV.



ioctl: <sys/ioctl.h>, <sys/ttycom.h>
	int ioctl(int fd, unsigned long request, ...)
	man
	Системный вызов ioctl() манипулирует базовыми параметрами устройства специальных
	файлов. В частности, многие рабочие характеристики символьных специальных файлов
	(например, терминалов) могут управляться с помощью запросов ioctl(). Аргумент fd
	должен быть дескриптором открытого файла.

    Второй аргумент - это зависимый от устройства код запроса. Третий аргумент -
	нетипизированный указатель на память. Это традиционно char * argp (за несколько
	дней до того, как void * был действительным C), и будет назван так в этом
	обсуждении.

    Запрос ioctl() закодировал в нем, является ли аргумент входным параметром или
	выходным параметром, и размер аргумента argp в байтах. Макросы и определения,
	используемые при указании запроса ioctl(), находятся в файле <sys / ioctl.h>.

	Имена констант для терминального ввода\вывода "TIOxxx".

	return():
		Обычно в случае успеха возвращается ноль. Несколько запросов ioctl()
		используют возвращаемое значение в качестве выходного параметра и возвращают
		неотрицательное значение в случае успеха. В случае ошибки возвращается -1 и
		значение errno устанавливается соответствующим образом.



STDERR_FILENO
    File number of stderr; 2.
STDIN_FILENO
    File number of stdin; 0.
STDOUT_FILENO
    File number of stdout; 1.